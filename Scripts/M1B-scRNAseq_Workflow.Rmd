### A step-by-step workflow for low-level analysis of single-cell RNA-seq data 

<!-- Part II - Analysis of cell types in the brain -->

<style type="text/css"> body, td { font-size: 14px; } code.r{ font-size: 12px; } pre { font-size: 12px } </style>

[bioconductor workflows simpleSingleCell](https://www.bioconductor.org/help/workflows/simpleSingleCell/)


```{r Prelims, include=F, echo=FALSE, results='hide', message=FALSE}

  FN <- "M1B-scRNAseq_Workflow"

  suppressMessages(require(rmarkdown))
  suppressMessages(require(knitr))
  options(stringsAsFactors=F)

  # Shotcuts for knitting and redering while in R session
  kk <- function(n='') knit2html(paste("Scripts/t", n, sep=''), envir=globalenv(),
        output=paste('Scripts/',FN,".html", sep=''))
  bb <- function(n='') browseURL(paste('Scripts/',FN,".html", sep=''))

  # The usual shorcuts
  zz <- function(n='') source(paste("Scripts/t", n, sep=''))

  if(file.exists('/Users/francois/Dropbox/SingleCell/Jun2017/R/'))
  WRKDIR <- '/Users/francois/Dropbox/SingleCell/Jun2017/R/'  else
  WRKDIR <- '/mnt100/home/Dropbox/SingleCell/Jun2017/R'

  # do once
  #setwd(WRKDIR)

  # file rmarkdown file management options: cache, figures
  cache_DIR <- file.path(WRKDIR, 'Scripts', 'cache/M1B/')
  suppressMessages(dir.create(cache_DIR, recursive=T))
  opts_chunk$set(cache.path=cache_DIR)

  figure_DIR <- file.path(WRKDIR, 'Scripts', 'figure/M1B/')
  suppressMessages(dir.create(figure_DIR, recursive=T))
  opts_chunk$set(fig.path=figure_DIR)

  # Options from SingleCell RNAseq Workflow
  opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
  opts_chunk$set(fig.width=11, fig.height=8)
  opts_chunk$set(dpi=300, dev="png", dev.args=list(pointsize=15))
  options(bitmapType="cairo", width=100)

```
<!-- ***************************************************** -->

```{r defFunctions, echo=F}
  # Place holder
```
<!-- ***************************************************** -->

```{r loadLibs, echo=F}
 suppressMessages(require(dplyr))
 suppressMessages(require(magrittr))

 suppressMessages(require(data.table))
 options(datatable.fread.datatable=F)

 suppressMessages(require(RColorBrewer))

 suppressMessages(require(edgeR))
 suppressMessages(require(limma))

 suppressMessages(require(Biobase))
 suppressMessages(require(GenomicRanges))  ### PROBLEM on Mac OS!!!
                                           
 suppressMessages(require(vcd))
 suppressMessages(require(stringr))
 suppressMessages(require(reshape2))
 suppressMessages(require(tidyr))
 suppressMessages(require(plyr))
 suppressMessages(require(dplyr))
 suppressMessages(require(irlba))
 suppressMessages(require(readr))
 suppressMessages(require(scater))        ### PROBLEM on Mac OS!!!

 suppressMessages(require(BiocStyle))

 suppressMessages(require(R.utils))
 suppressMessages(require(readxl))

 suppressMessages(require(Rtsne))

 # ABLE TO INSTALL mvoutlier and destiny - Finally!
 suppressMessages(require(mvoutlier))
 suppressMessages(require(destiny))

 suppressMessages(require(scran))

 # Setting single-core unless explicitly specified otherwise.
 suppressMessages(require(BiocParallel))
 register(SerialParam())

```
<!-- ***************************************************** -->


```{r setParam, echo=F}

 if(file.exists('/Users/francois/Dropbox/SingleCell/'))
 ROOT <- '/Users/francois/Dropbox/SingleCell/'  else
 ROOT <- '/mnt100/home/Dropbox/SingleCell/'

 EXT_DATA <- file.path(ROOT, 'Data')

 # Deciding whether we want to re-download everything or not.
 on.bioc <- TRUE


 TABLE_DIR <- file.path(WRKDIR, 'Scripts', 'tables', 'M1B')
 suppressMessages(dir.create(TABLE_DIR,recursive=T))
 
```
<!-- ***************************************************** -->


## Analysis of cell types in the brain


### Overview

We proceed to a more heterogeneous dataset from a study of cell types in the mouse brain (Zeisel et al. 2015). This contains approximately 3000 cells of varying types such as oligodendrocytes, microglia and neurons. Individual cells were isolated using the Fluidigm C1 microfluidics system and library preparation was performed on each cell using a UMI-based protocol. After sequencing, expression was quantified by counting the number of UMIs mapped to each gene. Count data for all endogenous genes, mitochondrial genes and spike-in transcripts were obtained from [http://linnarssonlab.org/cortex](http://linnarssonlab.org/cortex).

### Count loading

The count data are distributed across several files, so some work is necessary to consolidate them into a single matrix. We define a simple utility function for loading data in from each file. (We stress that this function is only relevant to the current dataset, and should not be used for other datasets. This kind of effort is generally not required if all of the counts are in a single file and separated from the metadata.)


```{r defReadFn, eval=T}
readFormat <- function(infile) { 
    # First column is empty.
    metadata <- read.delim(infile, stringsAsFactors=FALSE, header=FALSE, nrow=10)[,-1] 
    rownames(metadata) <- metadata[,1]
    metadata <- metadata[,-1]
    metadata <- as.data.frame(t(metadata))
    # First column after row names is some useless filler.
    counts <- read.delim(infile, stringsAsFactors=FALSE, header=FALSE, row.names=1, skip=11)[,-1] 
    counts <- as.matrix(counts)
    return(list(metadata=metadata, counts=counts))
}
```
<!-- ******************************************************** -->

Using this function, we read in the counts for the endogenous genes, ERCC spike-ins and mitochondrial genes.

```{r readData, eval=T}
 endo.data <- readFormat(file.path(EXT_DATA, "expression_mRNA_17-Aug-2014.txt"))
 spike.data <- readFormat(file.path(EXT_DATA, "expression_spikes_17-Aug-2014.txt"))
 mito.data <- readFormat(file.path(EXT_DATA, "expression_mito_17-Aug-2014.txt"))
```
<!-- ******************************************************** -->

We also need to rearrange the columns for the mitochondrial data, as the order is not consistent with the other files.

```{r reOrder, eval=T}
 m <- match(endo.data$metadata$cell_id, mito.data$metadata$cell_id)
 mito.data$metadata <- mito.data$metadata[m,]
 mito.data$counts <- mito.data$counts[,m]
```
<!-- ******************************************************** -->
 
In this particular data set, some genes are represented by multiple rows corresponding to alternative genomic locations. We sum the counts for all rows corresponding to a single gene for ease of interpretation.

```{r sumRows, eval=T}
 stopifnot(identical(endo.data$metadata$cell_id, spike.data$metadata$cell_id)) # should be the same.
 stopifnot(all(endo.data$metadata$cell_id==mito.data$metadata$cell_id)) # should now be the same.
 
 raw.names <- sub("_loc[0-9]+$", "", rownames(endo.data$counts))
 new.counts <- rowsum(endo.data$counts, group=raw.names, reorder=FALSE)
 endo.data$counts <- new.counts

```
<!-- ******************************************************** -->

The counts are then combined into a single matrix for constructing a **SCESet** object. For convenience, metadata for all cells are stored in the same object for later access.
 
```{r getSCESet, eval=T}
 Cortex.Counts.frm <- rbind(endo.data$counts, mito.data$counts, spike.data$counts)
 
 metadata <- AnnotatedDataFrame(endo.data$metadata)
 Cortex.sce <- newSCESet(countData=Cortex.Counts.frm, phenoData=metadata)
 dim(Cortex.sce)
 
```
<!-- ******************************************************** -->

We also add annotation identifying rows that correspond to each class of features.

```{r annot,eval=T} 
 ## ------------------------------------------------------------------------
 nrows <- c(nrow(endo.data$counts), nrow(mito.data$counts), nrow(spike.data$counts))
 is.spike <- rep(c(FALSE, FALSE, TRUE), nrows)
 is.mito <- rep(c(FALSE, TRUE, FALSE), nrows)

```{r cleanUp, echo=F, include=F, eval=T}
 # Save some memory.
 rm(mito.data, endo.data, spike.data, new.counts)
 suppressMessages(gc())
```
<!-- ******************************************************** -->

### Quality control on the cells

The original authors of the study have already removed low-quality cells prior to data publication. Nonetheless, we compute some quality control metrics to check whether the remaining cells are satisfactory.

```{r calcQC, eval=T}
 Cortex.sce <- calculateQCMetrics(Cortex.sce, feature_controls=list(Spike=is.spike, Mt=is.mito)) 
 setSpike(Cortex.sce) <- "Spike"

 # save this
 save(Cortex.sce, file=file.path(WRKDIR, 'Data', 'Cortex.sce'))

```
<!-- ******************************************************** -->

We examine the distribution of library sizes and numbers of expressed genes across cells (Figure 15).

 
#### Figure 15:
* Histograms of library sizes (left) and number of expressed genes (right) for all cells in the brain dataset.
```{r libplotbrain}
 load(file.path(WRKDIR, 'Data', 'Cortex.sce'))

 par(mfrow=c(1,2))
 hist(Cortex.sce$total_counts/1e3, xlab="Library sizes (thousands)", main="", 
     breaks=20, col="grey80", ylab="Number of cells")
 hist(Cortex.sce$total_features, xlab="Number of expressed genes", main="", 
     breaks=20, col="grey80", ylab="Number of cells")
```
<!-- ******************************************************** -->

We also examine the distribution of the proportions of UMIs assigned to mitochondrial genes or spike-in transcripts (Figure 16). The spike-in proportions here are more variable than in the HSC dataset. This may reflect a greater variability in the total amount of endogenous RNA per cell when many cell types are present.
 

#### Figure 16:
* Histogram of the proportion of UMIs assigned to mitochondrial genes (left) or spike-in transcripts (right) across all cells in the brain dataset.

```{r UMIplot}
 par(mfrow=c(1,2))
 hist(Cortex.sce$pct_counts_feature_controls_Mt, xlab="Mitochondrial proportion (%)", 
     ylab="Number of cells", breaks=20, main="", col="grey80")
 hist(Cortex.sce$pct_counts_feature_controls_Spike, xlab="ERCC proportion (%)",
     ylab="Number of cells", breaks=20, main="", col="grey80")
 
```
<!-- ******************************************************** -->

We remove small outliers in Figure 15 and large outliers in Figure 16, using a MAD-based threshold as previously described.

```{r idOutliers}
 libsize.drop <- isOutlier(Cortex.sce$total_counts, nmads=3, type="lower", log=TRUE)
 feature.drop <- isOutlier(Cortex.sce$total_features, nmads=3, type="lower", log=TRUE)
 mito.drop <- isOutlier(Cortex.sce$pct_counts_feature_controls_Mt, nmads=3, type="higher")
 spike.drop <- isOutlier(Cortex.sce$pct_counts_feature_controls_Spike, nmads=3, type="higher")
```
<!-- ******************************************************** -->

Removal of low-quality cells is then performed by combining the filters for all of the metrics. The vast majority of cells are retained, which suggests that the original quality control procedures were generally adequate.


```{r rmOutliers} 
 Cortex.sce <- Cortex.sce[,!(libsize.drop | feature.drop | spike.drop | mito.drop)]
 data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), 
     ByMito=sum(mito.drop), BySpike=sum(spike.drop), Remaining=ncol(Cortex.sce))
```
<!-- ******************************************************** -->

### Cell cycle classification

Application of **cyclone** to the brain dataset suggests that most of the cells are in G1 phase (Figure 17). However, the intepretation of this result requires some caution due to the differences between the test and training datasets. The classifier was trained on C1 SMARTer data (Scialdone et al. 2015) and accounts for the biases in that protocol. The brain dataset uses UMI counts, which has an entirely different set of biases, e.g., 3’-end coverage only, no length bias, no amplification noise. These new biases (and the absence of expected biases) may interfere with accurate classification of some cells.

 
```{r, echo=F, include=F}
 gc()
```
 
#### Figure 17:
* Cell cycle phase scores from applying the pair-based classifier on the brain dataset, where each point represents a cell.

```{r phasePlot, cache=T, cache.vars=''}

 mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", 
           package="scran"))

 suppressMessages(require(org.Mm.eg.db))
 anno <- select(org.Mm.eg.db, keys=rownames(Cortex.sce), 
                keytype="SYMBOL", column="ENSEMBL")
 ensembl <- anno$ENSEMBL[match(rownames(Cortex.sce), anno$SYMBOL)]
 assignments <- cyclone(Cortex.sce, mm.pairs, gene.names=ensembl)
 plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", 
      ylab="G2/M score", pch=16)
 abline(0,1, col='red')
 abline(h=.5, v=0.5, col='blue', lty=2) 
```
<!-- ******************************************************** -->
```{r, echo=F, include=F}
 gc()
```

An additional complication is that many neuronal cell types are expected to lie in the G0 resting phase, which is distinct from the other phases of the cell **cycle** (Coller, Sang, and Roberts 2006). Application of cyclone to these cells may be suboptimal if each cell must be assigned into one of the G1, S or G2/M phases. To avoid problems from misclassification, we will not perform any processing of this dataset by cell cycle phase. This is unlikely to be problematic for this analysis, as the cell cycle effect will be relatively subtle compared to the obvious differences between cell types in a diverse population. Thus, the former is unlikely to distort the conclusions regarding the latter.
 

### Removing uninteresting genes

Low-abundance genes are removed by applying a simple mean-based filter. We use a lower threshold for UMI counts compared to that used for read counts. This is because the number of transcript molecules will always be lower than the number of reads generated from such molecules. While some information and power will be lost due to the decrease in the size of the counts, this is mitigated by a concomitant reduction in the variability of the counts. Specifically, the use of UMIs eliminates technical noise due to amplification biases (Islam et al. 2014).


#### Figure 18:
* Histogram of log-average counts for all genes in the brain dataset. The filter threshold is represented by the blue line.

Figure 18 suggests that our choice of threshold is appropriate. The filter removes the bulk of lowly expressed genes while preserving the peak of moderately expressed genes.

```{r abhist}
 ave.counts <- calcAverage(Cortex.sce)
 keep <- ave.counts >= 0.1
 
 hist(log10(ave.counts), breaks=100, main="", col="grey",
     xlab=expression(Log[10]~"average count"))
 abline(v=log10(0.1), col="blue", lwd=2, lty=2)
 
```
<!-- ******************************************************** -->

The mean-based filter is applied to the dataset by subsetting sce as previously described. Despite the reduced threshold, the number of retained genes is lower than that in the HSC dataset, simply because the library sizes are much smaller with UMI counts.


```{r applyFilter}
 Cortex.sce <- Cortex.sce[keep,]
 nrow(Cortex.sce)
```
<!-- ******************************************************** -->
```{r, echo=F, include=F}
 gc()
```
 
Some datasets also contain strong heterogeneity in mitochondrial RNA content, possibly due to differences in mitochondrial copy number or activity between cell types. This heterogeneity will cause mitochondrial genes to dominate the top set of results, e.g., for identification of correlated HVGs. However, these genes are largely uninteresting given that most studies focus on nuclear regulation. As such, we filter them out prior to further analysis. Other candidates for removal include pseudogenes or ribosome-associated genes, which might not be relevant for characterising cell types but can still interfere with the interpretation of the results.


```{r rmMt}
 Cortex.sce <- Cortex.sce[!fData(Cortex.sce)$is_feature_control_Mt,]
```
<!-- ******************************************************** -->
```{r, echo=F, include=F}
 gc()
```
 
### Normalization of cell-specific biases

Normalization of cell-specific biases is performed using the deconvolution method in the **computeSumFactors** function. Here, we cluster similar cells together and normalize the cells in each cluster using the deconvolution method. This improves normalization accuracy by reducing the number of DE genes between cells in the same cluster. Scaling is then performed to ensure that size factors of cells in different clusters are comparable.

 
```{r clusterCells, cache=T, cache.vars='Cortex.sce'}
 clusters <- quickCluster(Cortex.sce)
 Cortex.sce <- computeSumFactors(Cortex.sce, cluster=clusters)
 summary(sizeFactors(Cortex.sce))
```
<!-- ******************************************************** -->
```{r, echo=F, include=F}
 gc()
```
 
Compared to the HSC analysis, more scatter is observed around the trend between the total count and size factor for each cell (Figure 19). This is consistent with an increased amount of DE between cells of different types, which compromises the accuracy of library size normalization (Robinson and Oshlack 2010). In contrast, the size factors are estimated based on median ratios and are more robust to the presence of DE between cells.


#### Figure 19:
* Size factors from deconvolution, plotted against library sizes for all cells in the brain dataset. Axes are shown on a log-scale.

```{r plotNormFactors}
 plot(sizeFactors(Cortex.sce), Cortex.sce$total_counts/1e3, log="xy",
     ylab="Library size (thousands)", xlab="Size factor")
```
<!-- ******************************************************** -->

We also compute size factors specific to the spike-in set, as previously described.
 
```{r computeSpikeFactors}
 Cortex.sce <- computeSpikeFactors(Cortex.sce, type="Spike", general.use=FALSE)
```
<!-- ******************************************************** -->

Finally, normalized log-expression values are computed for each endogenous gene or spike-in transcript using the appropriate size factors.

 
```{r normalize}
 Cortex.sce <- normalize(Cortex.sce)
```
<!-- ******************************************************** -->
 

### Checking for important technical factors

Larger experiments contain more technical factors that need to be investigated. In this dataset, factors include the sex of the animal from which the cells were extracted, the age of the animal, the tissue of origin for each cell, and the total spike-in count in each cell. Figure 20 shows that the tissue of origin explains a substantial proportion of the variance for a subset of genes. This is probably because each tissue contains a different composition of cell types, leading to systematic differences in gene expression between tissues. The other factors explain only a small proportion of the variance for most genes and do not need to be incorporated into our downstream analyses.


#### Figure 20:
* Density plot of the percentage of variance explained by each factor across all genes in the brain dataset. For each gene, the percentage of the variance of the normalized log-expression values that is explained by the (log-transformed) total spike-in counts, the sex or age of the mouse, or the tissue of origin is calculated. Each curve corresponds to one factor and represents the distribution of percentages across all genes.

```{r plotExplanatoryVariables}
 fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
 plotExplanatoryVariables(Cortex.sce, variables=c("counts_feature_controls_Spike", 
     "log10_counts_feature_controls_Spike", "sex", "tissue", "age")) + fontsize
```
<!-- **************************************************************** -->

#### Replot as pairs
```{r pairsExplanatoryVariables}
 fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
 plotExplanatoryVariables(Cortex.sce, method='pairs',
    variables=c("counts_feature_controls_Spike", "log10_counts_feature_controls_Spike", 
                "sex", "tissue", "age")) + fontsize
```
<!-- **************************************************************** -->

Nonetheless, we demonstrate how to account for uninteresting technical factors by using sex as an example. We set up a design matrix with the sex of the animal as the explanatory factor for each cell. This ensures that any sex-specific changes in expression will be modelled in our downstream analyses. We do not block on the tissue of origin, despite the fact that it explains more of the variance than sex in Figure 20. This is because the tissue factor is likely to be associated with genuine differences between cell types, so including it in the model might regress out interesting biological effects.

```{r design}
 design <- model.matrix(~Cortex.sce$sex)
```
<!-- **************************************************************** -->

Other relevant factors include the chip or plate on which the cells were processed and the batch in which the libraries were sequenced. Blocking on these factors may be necessary to account for batch effects that are often observed in scRNA-seq data (Hicks, Teng, and Irizarry 2015; Tung et al. 2016).

### Identifying correlated HVGs

We identify HVGs that may be involved in driving population heterogeneity. This is done by fitting a trend to the technical variances for the spike-in transcripts. We compute the biological component of the variance for each endogenous gene by subtracting the fitted value of the trend from the total variance. To account for uninteresting factors, we supply **design** to **trendVar** to regress out any technical differences due to sex. HVGs are then detected in the same manner as described in the HSC data analysis.

```{r hvg}

 var.fit.des <- trendVar(Cortex.sce, trend="loess", span=0.4, design=design)
 var.out.des <- decomposeVar(Cortex.sce, var.fit.des)
 hvg.out.des <- var.out.des[which(var.out.des$FDR <= 0.05 & var.out.des$bio >= 0.5),]
 nrow(hvg.out.des)

```
<!-- **************************************************************** -->
 
Alternatively, for data sets containing multiple batches, a more robust strategy is to perform trend fitting and variance decomposition separately for each batch. This accommodates differences in the mean-variance trends between batches, especially if a different amount of spike-in RNA was added to the cells in each batch. We demonstrate the second approach below by treating each sex as a different “batch”.

```{r blockedVarDecomp}
 collected <- list()
 for (block in levels(as.factor(Cortex.sce$sex))) {
     cur.Cortex.sce <- Cortex.sce[,Cortex.sce$sex==block]
     cur.Cortex.sce <- normalize(cur.Cortex.sce) 
     var.fit <- trendVar(cur.Cortex.sce, trend="loess", span=0.4)
     collected[[block]] <- decomposeVar(cur.Cortex.sce, var.fit)
 }

```
<!-- **************************************************************** -->

Figure 21 suggests that the trend is fitted accurately to the technical variances for each sex. Errors in fitting are negligible due to the precision of the variance estimates in a large dataset containing thousands of cells. The technical and total variances are also much smaller than those in the HSC dataset. This is due to the use of UMIs which reduces the noise caused by variable PCR amplification. Furthermore, the spike-in trend is consistently lower than the variances of the endogenous genes. This reflects the heterogeneity in gene expression across cells of different types. It also means the previous strategy of fitting a trend to the endogenous variances would not be appropriate here (or necessary, given the quality of the spike-in trend).

 
```{r, echo=F, include=F}
 rm(cur.Cortex.sce)
 gc()
```
<!-- **************************************************************** -->
 
### Figure 21:
* Variance of normalized log-expression values against the mean for each gene, calculated across all cells from male (left) or female mice (right). In each plot, the red line represents the mean-dependent trend in the technical variance of the spike-in transcripts (also highlighted as red points).

```{r hvgplot}
 par(mfrow=c(1,2))
 for (block in c("1", "-1")) { 
     var.out <- collected[[block]]
     plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
         ylab="Variance of log-expression", main=ifelse(block=="1", "Male", "Female"))
     points(var.out$mean[isSpike(Cortex.sce)], var.out$total[isSpike(Cortex.sce)], col="red", pch=16)
     o <- order(var.out$mean)
     lines(var.out$mean[o], var.out$tech[o], col="red", lwd=2)
 }

``` 
<!-- **************************************************************** -->

Statistics are combined across the two sexes using the **combineVar** function. HVGs are identified as genes with large positive biological components, and are saved to file for future reference. Note that some of the p-values are reported as zero due to numerical imprecision.

```{r getHVG}
 var.out <- do.call(combineVar, collected)
 hvg.out <- var.out[which(var.out$FDR <= 0.05 & var.out$bio >= 0.5),]
 hvg.out <- hvg.out[order(hvg.out$bio, decreasing=TRUE),] 
 nrow(hvg.out)
 write.table(file=file.path(TABLE_DIR,"brain_hvg.tsv"), 
      hvg.out, sep="\t", quote=FALSE, col.names=NA)
 head(hvg.out)
 
```
<!-- **************************************************************** -->

#### Figure 22:
* Violin plots of normalized log-expression values for the top 10 HVGs in the brain dataset. For each gene, each point represents the log-expression value for an individual cell.

```{r hvgvioplotbrain}
 plotExpression(Cortex.sce, rownames(hvg.out)[1:10], alpha=0.05, jitter="jitter") + fontsize
```
<!-- **************************************************************** -->

To identify genes involved in defining subpopulations, correlations in the expression profiles are calculated between pairs of HVGs. Correlated HVGs are defined as those with significant correlations to one or more other HVGs at a FDR of 5%. Here, the proportion of HVGs with significant correlations is much higher than in the HSC dataset, indicating that strong substructure is present.

```{r idHVG} 
 set.seed(100)
 var.cor <- correlatePairs(Cortex.sce, design=design, subset.row=rownames(hvg.out), per.gene=TRUE)
 write.table(file="brain_cor.tsv", var.cor, sep="\t", quote=FALSE, row.names=FALSE)
 head(var.cor)
 sig.cor <- var.cor$FDR <= 0.05
 summary(sig.cor)
```
<!-- **************************************************************** -->
 
### Further data exploration with the correlated HVGs

We first remove the sex effect using the **removeBatchEffect** function from the **limma** package (Ritchie et al. 2015). This ensures that any sex-specific differences will not dominate the visualization of the expression profiles. In this manner, we maintain consistency with the use of design in the previous steps. (However, if an analysis method can accept a design matrix, blocking on nuisance factors in the design matrix is preferable to manipulating the expression values with **removeBatchEffect.** This is because the latter does not account for the loss of residual degrees of freedom, nor the uncertainty of estimation of the blocking factor terms.) We store these sex-corrected expression values in the **norm_exprs** field of the **SCESet** object for later use.

```{r removeBathEffects}

 suppressMessages(require(limma))
 adj.exprs <- exprs(Cortex.sce)
 adj.exprs <- removeBatchEffect(adj.exprs, batch=Cortex.sce$sex)
 norm_exprs(Cortex.sce) <- adj.exprs 

```
<!-- **************************************************************** -->

We perform dimensionality reduction on the correlated HVGs to check if there is any substructure. Cells separate into clear clusters in the t-SNE plot (Figure 23), corresponding to distinct subpopulations. This is consistent with the presence of multiple cell types in the diverse brain population.

 
#### Figure 23:
* _t_-SNE plots constructed from the normalized and corrected log-expression values of correlated HVGs for cells in the brain dataset. Each point represents a cell and is coloured according to its expression of the top HVG (left) or _Mog_ (right).

```{r tsneplot, cache=T, cache.vars=c('chosen', 'top.hvg')}
 DUMMY <- 0
 chosen <- var.cor$gene[sig.cor]
 top.hvg <- rownames(hvg.out)[1]
 tsne1 <- plotTSNE(Cortex.sce, exprs_values="norm_exprs", colour_by=top.hvg,
     perplexity=10, rand_seed=100, feature_set=chosen) + fontsize
 tsne2 <- plotTSNE(Cortex.sce, exprs_values="norm_exprs", colour_by="Mog",
     perplexity=10, rand_seed=100, feature_set=chosen) + fontsize
 multiplot(tsne1, tsne2, cols=2)

```
<!-- **************************************************************** -->
 
```{r, echo=F, include=F}
 rm(var.cor)
 gc()
```

The PCA plot is less effective at separating cells into many different clusters (Figure 24). This is because the first two principal components (PCs) are driven by strong differences between specific subpopulations, which reduces the resolution of more subtle differences between some of the other subpopulations. Nonetheless, some substructure is still visible.

 
#### Figure 24:
* PCA plots constructed from the normalized and corrected log-expression values of correlated HVGs for cells in the brain dataset. Each point represents a cell and is coloured according to its expression of the top HVG (left) or _Mog_ (right).

```{r PCAplot}
 pca1 <- plotPCA(Cortex.sce, exprs_values="norm_exprs", colour_by=top.hvg) + fontsize
 pca2 <- plotPCA(Cortex.sce, exprs_values="norm_exprs", colour_by="Mog") + fontsize
 multiplot(pca1, pca2, cols=2)
```
<!-- **************************************************************** -->

For both methods, we colour each cell based on the expression of a particular gene. This is a useful strategy for visualizing changes in expression across the lower-dimensional space. It can also be used to characterise each cluster if the selected genes are known markers for particular cell types. For example, Mog can be used to identify clusters corresponding to oligodendrocytes.

### Clustering cells into putative subpopulations

The normalized and sex-adjusted log-expression values for correlated HVGs are used to cluster cells into putative subpopulations. Specifically, we perform hierarchical clustering on the Euclidean distances between cells, using Ward’s criterion to minimize the total variance within each cluster. This yields a dendrogram that groups together cells with similar expression patterns across the chosen genes. An alternative approach is to cluster on a matrix of distances derived from correlations (e.g., as in **quickCluster**). This is more robust to noise and normalization errors, but is also less sensitive to subtle changes in the expression profiles.

Clusters are explicitly defined by applying a dynamic tree cut (Langfelder, Zhang, and Horvath 2008) to the dendrogram. This exploits the shape of the branches in the dendrogram to refine the cluster definitions, and is more appropriate than **cutree** for complex dendrograms. Greater control of the empirical clusters can be obtained by manually specifying **cutHeight** in **cutreeDynamic.**

```{r hclust} 
 suppressMessages(require(dynamicTreeCut))

 chosen.exprs <- norm_exprs(Cortex.sce)[chosen,]
 my.dist <- dist(t(chosen.exprs))
 my.tree <- hclust(my.dist, method="ward.D2")
 
 my.clusters <- unname(cutreeDynamic(my.tree, distM=as.matrix(my.dist), verbose=0))
```
<!-- **************************************************************** -->

Figure 25 contains a clear block-like pattern, representing systematic differences between clusters of cells with distinct expression profiles. This is consistent with the presence of well-defined subpopulations that were previously observed in the dimensionality reduction plots.

 
### Figure 25:
* Heatmap of mean-centred normalized and corrected log-expression values for correlated HVGs in the brain dataset. Dendrograms are formed by hierarchical clustering on the Euclidean distances between genes (row) or cells (column). Column colours represent the cluster to which each cell is assigned after a dynamic tree cut. Heatmap colours are capped at a maximum absolute log-fold change of 5."----
`
```{r heatMap}
 suppressMessages(require(gplots))

 heat.vals <- chosen.exprs - rowMeans(chosen.exprs)
 clust.col <- rainbow(max(my.clusters))
 heatmap.2(heat.vals, col=bluered, symbreak=TRUE, trace='none', cexRow=0.3,
     ColSideColors=clust.col[my.clusters], Colv=as.dendrogram(my.tree), 
     breaks=seq(-5, 5, length.out=21))
```
<!-- **************************************************************** -->

 
This heatmap can be stored at a greater resolution for detailed inspection later. It is advisable to verify the separatedness of the clusters using metrics such as the silhouette width or gap statistic (see the **cluster** package for details). The same statistics can also be used to gauge the optimal parameter values (e.g., cut height, number of clusters) that maximize the separation between clusters.

```{r heatMap2}
 pdf(file.path(TABLE_DIR,"brain_heat.pdf"), width=10, height=100) # Large 'height' to show all gene names.
 heatmap.2(heat.vals, col=bluered, symbreak=TRUE, trace='none', cexRow=0.3,
     ColSideColors=clust.col[my.clusters], Colv=as.dendrogram(my.tree), 
     lwid=c(1, 4), lhei=c(1, 50), # Avoid having a very large colour key.
     breaks=seq(-5, 5, length.out=21))
 dev.off()
```
<!-- **************************************************************** -->
 
A complementary approach is to perform PCA on the log-expression values for correlated HVGs and cluster on the first few PCs. This assumes that random technical noise in each gene will be represented by later PCs, while biological substructure involving coregulated groups of genes will contribute more variance and be represented by earlier PCs. The **denoisePCA** function will remove later PCs until the total discard variance is equal to the sum of technical components for all genes used in the PCA. This eliminates technical noise and enriches for biological signal in the remaining PCs, allowing for improved resolution during clustering.


```{r deNoise}
 # Using the technical components computed with a design matrix.
 pcs <- denoisePCA(Cortex.sce, design=design, technical=var.fit.des$trend, subset.row=chosen) 
 dim(reducedDimension(pcs)) # Cluster on this instead of t(chosen.exprs)
```
<!-- **************************************************************** -->
```{r, echo=F, include=F}
 gc()
```
 
When examining very heterogeneous datasets, it can be useful to repeat the HVG detection and clustering using only the cells within a particular cluster. This can be achieved by subsetting **sce** according to a particular level of **my.clusters**, and applying the same functions that were previously described. Doing so may identify a different set of correlated HVGs that define heterogeneity within the cluster, as opposed to those that define differences between clusters. This would allow fine-scale structure within each cluster to be explored at greater resolution. For simplicity, though, we will only use the broad clusters corresponding to clear subpopulations in this workflow.


### Detecting marker genes between subpopulations

Once putative subpopulations are identified by clustering, we can identify marker genes for each cluster using the **findMarkers** function. This fits a linear model to the log-expression values for each gene, using methods in the **limma** package (Law et al. 2014; Ritchie et al. 2015). The aim is to test for DE in each cluster compared to the others while blocking on uninteresting factors in **design**. The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters.

```{r findMarkers}
 markers <- findMarkers(Cortex.sce, my.clusters, design=design)
```
 
For each cluster, the DE results of the relevant comparisons are consolidated into a single output table. This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters. For example, to construct a marker set for cluster 1 from the top 10 genes of each comparison, one would filter **marker.set** to retain rows with **Top** less than or equal to 10. Other statistics are also reported for each gene, including the adjusted p-values (see below) and the log-fold changes relative to every other cluster.

```{r lkMarkers}
 old.digits <- options()$digits
 options(digits=3)
 
 marker.set <- markers[["1"]]
 print(kable(head(marker.set, 10)))
 
 options(digits=old.digits)

 write.table(marker.set, file=file.path(TABLE_DIR,"brain_marker_1.tsv"), 
         sep="\t", quote=FALSE, col.names=NA)
```
We save the list of candidate marker genes for further examination. The **overlapExprss** function may also be useful here, to prioritize candidates where there is clear separation between the distributions of expression values of different clusters.

We visualize the expression profiles of the top candidates to verify that the DE signature is robust. Figure 26 indicates that most of the top markers have strong and consistent up- or downregulation in cells of cluster 1 compared to some or all of the other clusters. Thus, cells from the subpopulation of interest can be identified as those that express the upregulated markers and do not express the downregulated markers.
 
#### Figure 26:
* Heatmap of mean-centred normalized and corrected log-expression values for the top set of markers for cluster 1 in the brain dataset. Column colours represent the cluster to which each cell is assigned, as indicated by the legend.

```{r heatmapmarker}
 top.markers <- marker.set$Gene[marker.set$Top <= 10]
 top.exprs <- norm_exprs(Cortex.sce)[top.markers,,drop=FALSE]
 heat.vals <- top.exprs - rowMeans(top.exprs)
 heatmap.2(heat.vals, col=bluered, symbreak=TRUE, trace='none', cexRow=0.6,
     ColSideColors=clust.col[my.clusters], Colv=as.dendrogram(my.tree), dendrogram='none')
 legend("bottomleft", col=clust.col, legend=sort(unique(my.clusters)), pch=16)
```

Many of the markers in Figure 26 are not uniquely up- or downregulated in the chosen cluster. Testing for unique DE tends to be too stringent as it overlooks important genes that are expressed in two or more clusters. For example, in a mixed population of CD4+-only, CD8+-only, double-positive and double-negative T cells, neither Cd4 or Cd8 would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations. With our approach, both of these genes will be picked up as candidate markers as they will be DE between at least one pair of subpopulations. A combination of markers can then be chosen to characterize a subpopulation, which is more flexible than trying to find uniquely DE genes.

It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of significance. This is because the clusters have been empirically identified from the data. **limma** does not account for the uncertainty of clustering, which means that the p-values are much lower than they should be. However, this is not a concern in other analyses where the groups are pre-defined. For such analyses, the FDR-adjusted p-value can be directly used to define significant genes for each DE comparison, though some care may be required to deal with plate effects (Hicks, Teng, and Irizarry 2015; Tung et al. 2016). 

The *8SCESet** object can also be easily transformed for use in other DE analysis methods. For example, the **convertTo** function can be used to construct a **DGEList** for input into the **edgeR** pipeline (Robinson, McCarthy, and Smyth 2010). This allows users to construct their own marker detection pipeline, though we find that direct use of **findMarkers** is usually sufficient.

```{r convertDGEList}
 library(edgeR)
 y <- convertTo(Cortex.sce, type="edgeR")
```

### Additional comments

Having completed the basic analysis, we save the SCESet object with its associated data to file. This is especially important here as the brain dataset is quite large. If further analyses are to be performed, it would be inconvenient to have to repeat all of the pre-processing steps described above.

```{r save}
 save(file=file.path(WRKDIR,'Data',"Cortex.sce"), Cortex.sce)
```

 ### Parameter settings:
   * WRKDIR = `r WRKDIR`
   * FN = `r FN`
   * Scripts = Scripts
   * EXT_DATA = `r EXT_DATA`
   * TABLE_DIR = `r TABLE_DIR` 
   * RUN DATE = `r date()`
 
 
```{r, echo=F}
  sessionInfo()
 ### STOP HERE
   knit_exit()
```
 
 
<!-- To run
 
 nohup sudo Rscript -e "knitr::knit2html('M1B-scRNAseq_Workflow.Rmd')" > M1B-scRNAseq_Workflow.log  &
 
-->
 
